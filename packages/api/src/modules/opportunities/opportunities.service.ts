import { Injectable, Logger, BadRequestException, NotFoundException } from '@nestjs/common';
import { SupabaseService, Opportunity, OfferType, OpportunityStatus } from '../../services/supabase.service';

export interface CreateOpportunityDto {
  rid: number;
  name: string;
  slug?: string;
  goal?: 'traffic' | 'leads' | 'orders' | 'awareness';
  offer_type: OfferType;
  start_date?: string;
  end_date?: string;
  status?: OpportunityStatus;
  metadata?: Record<string, unknown>;
}

export interface UpdateOpportunityDto {
  name?: string;
  slug?: string;
  goal?: 'traffic' | 'leads' | 'orders' | 'awareness';
  start_date?: string;
  end_date?: string;
  status?: OpportunityStatus;
  metadata?: Record<string, unknown>;
}

@Injectable()
export class OpportunitiesService {
  private readonly logger = new Logger(OpportunitiesService.name);

  constructor(private supabase: SupabaseService) {}

  async getAll(rid?: number): Promise<Opportunity[]> {
    return this.supabase.getOpportunities(rid);
  }

  async getById(id: string): Promise<Opportunity> {
    const opportunity = await this.supabase.getOpportunity(id);
    if (!opportunity) {
      throw new NotFoundException(`Opportunity not found: ${id}`);
    }
    return opportunity;
  }

  async getByPk(rid: number, pk: number): Promise<Opportunity> {
    const opportunity = await this.supabase.getOpportunityByPk(rid, pk);
    if (!opportunity) {
      throw new NotFoundException(`Opportunity not found: rid=${rid}, pk=${pk}`);
    }
    return opportunity;
  }

  async create(dto: CreateOpportunityDto): Promise<Opportunity> {
    // Validate restaurant exists
    const restaurant = await this.supabase.getRestaurantByRid(dto.rid);
    if (!restaurant) {
      throw new BadRequestException(`Restaurant not found: rid=${dto.rid}`);
    }

    // Generate slug if not provided
    const slug = dto.slug || this.generateSlug(dto.name);

    // Create opportunity (PK is auto-generated by SERIAL)
    const opportunity = await this.supabase.createOpportunity({
      rid: dto.rid,
      name: dto.name,
      slug,
      goal: dto.goal || 'traffic',
      offer_type: dto.offer_type,
      start_date: dto.start_date || null,
      end_date: dto.end_date || null,
      status: dto.status || 'active',
      metadata: dto.metadata || {},
    });

    this.logger.log(`Created opportunity: pk=${opportunity.pk}, rid=${dto.rid}, name="${dto.name}"`);
    return opportunity;
  }

  async update(id: string, dto: UpdateOpportunityDto): Promise<Opportunity> {
    // Verify opportunity exists
    await this.getById(id);

    const updates: Partial<Opportunity> = {};
    if (dto.name !== undefined) updates.name = dto.name;
    if (dto.slug !== undefined) updates.slug = dto.slug;
    if (dto.goal !== undefined) updates.goal = dto.goal;
    if (dto.start_date !== undefined) updates.start_date = dto.start_date;
    if (dto.end_date !== undefined) updates.end_date = dto.end_date;
    if (dto.status !== undefined) updates.status = dto.status;
    if (dto.metadata !== undefined) updates.metadata = dto.metadata;

    const opportunity = await this.supabase.updateOpportunity(id, updates);
    this.logger.log(`Updated opportunity: ${id}`);
    return opportunity;
  }

  async delete(id: string): Promise<{ success: boolean }> {
    // Verify opportunity exists
    const opportunity = await this.getById(id);

    // Check if there are any ad sets linked to this opportunity
    const adSets = await this.supabase.getAdSets();
    const linkedAdSets = adSets.filter(as => as.opportunity_id === id);
    
    if (linkedAdSets.length > 0) {
      throw new BadRequestException(
        `Cannot delete opportunity pk=${opportunity.pk}: ${linkedAdSets.length} ad sets are linked to it. ` +
        `Delete or unlink the ad sets first.`
      );
    }

    await this.supabase.deleteOpportunity(id);
    this.logger.log(`Deleted opportunity: ${id}`);
    return { success: true };
  }

  /**
   * Get or create an opportunity for a given offer type
   * Used when processing posts via webhook - automatically finds or creates opportunity
   */
  async getOrCreateForOfferType(rid: number, offerType: OfferType, name?: string): Promise<Opportunity> {
    // First, try to find an active opportunity for this offer type
    const existing = await this.supabase.getActiveOpportunityByOfferType(rid, offerType);
    if (existing) {
      this.logger.log(`Using existing opportunity: pk=${existing.pk} for ${offerType}`);
      return existing;
    }

    // Create a new opportunity
    const defaultName = this.getDefaultOpportunityName(offerType);
    return this.create({
      rid,
      name: name || defaultName,
      offer_type: offerType,
      goal: this.getDefaultGoalForOfferType(offerType),
      status: 'active',
    });
  }

  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[ąĄ]/g, 'a')
      .replace(/[ęĘ]/g, 'e')
      .replace(/[óÓ]/g, 'o')
      .replace(/[śŚ]/g, 's')
      .replace(/[łŁ]/g, 'l')
      .replace(/[żŻźŹ]/g, 'z')
      .replace(/[ćĆ]/g, 'c')
      .replace(/[ńŃ]/g, 'n')
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');
  }

  private getDefaultOpportunityName(offerType: OfferType): string {
    const now = new Date();
    const month = now.toLocaleString('pl-PL', { month: 'long' });
    const year = now.getFullYear();
    
    const typeNames: Record<OfferType, string> = {
      event: 'Wydarzenie',
      lunch: 'Lunch Promo',
      promo: 'Promocja',
      product: 'Produkt',
      brand: 'Brand',
      info: 'Info',
    };

    return `${typeNames[offerType]} ${month} ${year}`;
  }

  private getDefaultGoalForOfferType(offerType: OfferType): 'traffic' | 'leads' | 'orders' | 'awareness' {
    switch (offerType) {
      case 'event':
        return 'awareness';
      case 'lunch':
      case 'promo':
      case 'product':
        return 'orders';
      case 'brand':
        return 'awareness';
      case 'info':
      default:
        return 'traffic';
    }
  }
}
